<!DOCTYPE html>
<html>
	<head>
		
		<link rel="stylesheet" href="jquery.syntax.css" type="text/css" media="screen" />
		<link rel="stylesheet" href="example.css" type="text/css" media="screen" />
	
		<script src="jquery-1.4.1.js" type="text/javascript"></script>
		
		<script src="jquery.syntax.js" type="text/javascript"></script>
		<script src="jquery.syntax.cache.js" type="text/javascript" charset='utf-8'></script>
		
		<script src="jquery.syntax.brush.clang.js" type="text/javascript"></script>
		<script src="jquery.syntax.layout.table.js" type="text/javascript"></script>
		
		<link rel="stylesheet" href="jquery.syntax.layout.table.css" type="text/css" media="screen">
		
		<script type="text/javascript" language="JavaScript">
		//<!--
			$(function() {
				$('#highlight').click(function() {
					window.console.profile("Syntax Highlighting");
					start = new Date();
					
					$('pre.clang').syntax({brush: 'clang', layout: 'table', replace: true}, function(options, html, container) {
						//$('.function', html).replaceWith(function(){
						//	return $('<a>').addClass('function').attr('href', '#' + $(this).text()).html($(this).html());
						//})
						
						finish = new Date();
						window.console.profileEnd();
						window.console.log(finish - start);
					});
				});
			});
		//-->
		</script>
 
	</head>
	<body>
		<h1>Syntax Highlighting Example</h1>
		
		<button id="highlight">Highlight</button>
		
		<pre class="clang">#include &lt;iostream&gt;

// If we increase row by 1, the offset will increase by sz (number of elements per row i.e. number of columns)
// If we increase col by 1, the offset will increase by 1
unsigned rowMajorOffset(unsigned row, unsigned col, unsigned sz)
{
    return col + row * sz;
}

// If we increase col by 1, the offset will increase by sz (number of elements per column i.e. number of rows)
// If we increase row by 1, the offset will increase by 1
unsigned columnMajorOffset(unsigned row, unsigned col, unsigned sz)
{
    return row + col * sz;
}

template &lt;typename _ValueT, unsigned _R, unsigned _C, bool _ColumnMajor&gt;
class Matrix {
protected:
	enum { ColumnMajor = _ColumnMajor };
	enum { R = _R };
	enum { C = _C };

	typedef _ValueT ValueT;

	ValueT m_values[C*R];

public:
	const ValueT &amp; at (unsigned r, unsigned c) const
	{
		if (ColumnMajor)
			return m_values[columnMajorOffset(r, c, R)];
		else
			return m_values[rowMajorOffset(r, c, C)];
	}

	ValueT &amp; at (unsigned r, unsigned c)
	{
		if (ColumnMajor)
			return m_values[columnMajorOffset(r, c, R)];
		else
			return m_values[rowMajorOffset(r, c, C)];
	}

	void loadTestPattern ()
	{
		for (unsigned r = 0; r &lt; R; r += 1)
			for (unsigned c = 0; c &lt; C; c += 1)
				at(r, c) = (r+1) * 1000 + (c+1);
	}

	void debug ()
	{
		using namespace std;

		if (ColumnMajor)
			cout &lt;&lt; &quot;Column-Major Matrix &quot; &lt;&lt; &quot;(&quot; &lt;&lt; R &lt;&lt; &quot;,&quot; &lt;&lt; C &lt;&lt; &quot;)&quot; &lt;&lt; &quot; @ &quot; &lt;&lt; this &lt;&lt; endl;
		else
			cout &lt;&lt; &quot;Row-Major Matrix &quot; &lt;&lt; &quot;(&quot; &lt;&lt; R &lt;&lt; &quot;,&quot; &lt;&lt; C &lt;&lt; &quot;)&quot; &lt;&lt; &quot; @ &quot; &lt;&lt; this &lt;&lt; endl;

		cout &lt;&lt; &quot;Memory Offset: &quot;;
		for (unsigned i = 0; i &lt; (R*C); i += 1)
			cout &lt;&lt; i &lt;&lt; &quot;    &quot;;
		cout &lt;&lt; endl;

		cout &lt;&lt; &quot;       Values: &quot;;	
		for (unsigned i = 0; i &lt; (R*C); i += 1)
			cout &lt;&lt; m_values[i] &lt;&lt; &quot; &quot;;
		cout &lt;&lt; endl;

		cout &lt;&lt; &quot;Standard Mathematical Notation:&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;      &quot;;
		for (unsigned c = 0; c &lt; C; c += 1)
			cout &lt;&lt; &quot;Col &quot; &lt;&lt; c &lt;&lt; &quot; &quot;;
		cout &lt;&lt; endl;

		for (unsigned r = 0; r &lt; R; r += 1) {
			cout &lt;&lt; &quot;Row &quot; &lt;&lt; r &lt;&lt; &quot; &quot;;
			for (unsigned c = 0; c &lt; C; c += 1)
				cout &lt;&lt; at(r, c) &lt;&lt; &quot;  &quot;;
			cout &lt;&lt; endl;
		}
		cout &lt;&lt; endl;
	}

	Matrix&lt;ValueT, R, C, !ColumnMajor&gt; transposeStorage () const
	{
		Matrix&lt;ValueT, R, C, !ColumnMajor&gt; result;

		for (unsigned r = 0; r &lt; R; r += 1)
			for (unsigned c = 0; c &lt; C; c += 1)
				result.at(r, c) = at(r, c);

		return result;
	}

	Matrix&lt;ValueT, C, R, !ColumnMajor&gt; transposeMatrix () const
	{
		Matrix&lt;ValueT, C, R, !ColumnMajor&gt; result;

		memcpy(&amp;result.at(0,0), m_values, sizeof(m_values));

		return result;
	}
};

int main (int argc, char * const argv[]) {
	Matrix&lt;float, 4, 2, false&gt; rowMajorMatrix;
	Matrix&lt;float, 4, 2, true&gt; columnMajorMatrix;

	rowMajorMatrix.loadTestPattern();
	rowMajorMatrix.debug();

	columnMajorMatrix.loadTestPattern();
	columnMajorMatrix.debug();

	rowMajorMatrix = columnMajorMatrix.transposeStorage();
	rowMajorMatrix.debug();

	Matrix&lt;float, 2, 4, false&gt; transposedMatrix = columnMajorMatrix.transposeMatrix();
	transposedMatrix.debug();

	return 0;
}</pre>

	</body>
</html>